#! /usr/bin/python


"""
   Copyright (C) 2000-2012, JAMK University of Applied Sciences 

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU testlink Public License as published by
   the Free Software Foundation, version 2.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>

"""


#	import xmlrpclib
import TestLinkAPI
import sys, os, time 
#	import subprocess
from twisted.python import log	
import yaml 
#from config import conf
from datetime import datetime
from xml.etree import ElementTree as ET
from git_puller import gitpuller
from engine_robot import robotEngine
from engine import Engine

def look_for_subclass(modulename):
	try:
		log.msg("Checking module: %s", modulename)
		module = __import__(modulename)

		# walk the dictionaries to get to the last one
		d = module.__dict__
		for m in modulename.split('.')[1:]:
		    	d = d[m].__dict__

		#look through this dictionary for the correct class
		for key, entry in d.items():
		    	if key == cls.__name__:
		        	continue
    			try:
    				if issubclass(entry, cls):
						log.msg("Found engine: %s", key)
						engines.append(entry)
    			except TypeError:
					#this happens when a non-type is passed in to issubclass. Non-types can't be instances, so they will be ignored.
					continue
		return "ok"

	except Exception, e:
		# if something goes wrong while loading modules, loading is aborted
		log.msg('Error while loading modules: %s', str(e))
		return "error"
		pass 

class fntc:
	def fntc_main(engine, ):    
		# getting variables from config
		f = open('/etc/testlink_client.conf')
		conf = yaml.load(f)
		f.close

		SERVER_URL = conf['testlink']['serverURL'] + "lib/api/xmlrpc.php"
		devKey = conf['testlink']['devkey']
		vOutputdir = conf['testlink']['outputdirectory']
		testdir = conf['testlink']['testingdirectory']
		logdir = conf['general']['logdir']
		log.msg('Getting parameters from command line')
		# catching the arguments Testlink sends 
	    #s = sys.argv[1] + " " + sys.argv[2] + " " + sys.argv[3] + " " + sys.argv[4] + " " + sys.argv[5] + " " + sys.argv[6] + " " + sys.argv[7] + " " + sys.argv[8]
		log.msg('Testvalues gained: %s', sys.argv)

	    #argv1= testCaseName
		#argv2= testCaseID
		#argv3= testCaseVersionID
		#argv4= testProjectID
		#argv5= testPlanID
		#argv6= platformID
		#argv7= buildID
		#argv8= executionMode


		# TestLink API could be used for getting values, for example test case names or 
		# project names directly from Testlink database. Those could be used as folder names
		# when combined with GIT
		# Dev key is needed for database access

		
		noproblems = 1
		engine_defined = False
		cls = Engine
		engines = []
		
		# defining Git class
		puller = gitpuller()

		# finding all Engine subclasses

		path = "usr/share/fntcservice/engine/"	# will look for classes under the folder where this script is installed and under its subclasses
	    	for root, dirs, files in os.walk(path):
	        	for name in files:
	            		if name.endswith(".py") and name.startswith("engine_"):
	                		path = os.path.join(root, name)
	                		modulename = path.rsplit('.', 1)[0].replace('/', '.')
					modulename = modulename.rsplit('.', 1)[1]
	                		result = look_for_subclass(modulename)
					if result == "error":
						break
		
		
		for e in engines:	#scroll through all found engines and find the correct one 
			if e.__name__ == cfEngine:
				engine = e(sys.argv[2], vOutputdir, testdir, sys.argv[8])
				engine_defined = True
				break

		if engine_defined == False:
			t = datetime.now()
			timestamp = t.strftime("%Y-%m-%d %H:%M:%S")
			log.msg('The correct testing engine was not found, tests cannot be run. Check the custom field value')
			resultstring = "b@@The correct testing engine was not found, tests cannot be run. Check the custom field value.@@" + timestamp + "@@now"
		else:
			# pull the latest test script versions from Git
			# TODO: maybe add a custom field / configuration and code for pulling from svn?
	        	gitresult = puller.pull(testdir)
	        	if gitresult != "ok":
	        	        log.msg('Git error: "%s", running old tests...', gitresult)
	        	        #noproblems = 0

		
			# how many times to run the tests, run at least one time 
			try:
				runtimes = int(runtimes)
			except Exception, e:
				# runtimes is not a number
				log.msg('Custom field "RunTimes" contains an invalid value, tests will be run only once')
				runtimes = 1


			# getting testing scripts
			scriptlist = cfScripts.split()

			eninge.init_environment()

			if noproblems == 1:
				# if everything is ok, run the tests
				log.msg('Starting Engine')
				
				engineresult = engine.run_tests(sys.argv[1], scriptlist, runtimes)
				if engineresult != "ok":
					t = datetime.now()
	                		timestamp = t.strftime("%Y-%m-%d %H:%M:%S")
	        	        	log.msg('Engine error: %s', engineresult)
					resultstring = "b@@Engine error: " + engineresult + "@@" + timestamp + "@@now"
					noproblems = 0

			if noproblems == 1:
				# Trying to get the results from engine
				log.msg('Trying to get test results')
				results = engine.get_test_results(sys.argv[1], runtimes, tolerance)
			

				resultstring = results[0] + "@@" + results[1] + "@@" + results[2] + "@@" + results[3]
		
			engine.teardown_environment()

		# Since the server saves the console output to a variable, I'll use print for 
		# returning the results
		# All results must be returned as one string

		# hardcoded return values for testing purposes
		#result = "p"
		#notes = "Just testing"
		#scheduled = sys.argv[8]
		#t = datetime.now()
	    #timestamp = t.strftime("%Y-%m-%d %H:%M:%S")
		
		 
	    log.msg('Returning results: %s', resultstring)
		print resultstring



if __name__ == "__main__":


	import logging 
	
	#create log file to see what's going on
    logger = logging.getLogger('engine_starter')
    logger.setLevel(logging.DEBUG)
    fh = logging.FileHandler('testlink_robot_client.log')
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(formatter)
    logger.addHandler(fh)
	
	# getting variables from config
	f = open('testlink_client.conf')
	conf = yaml.load(f)
	f.close

	SERVER_URL = conf['testlink']['serverURL'] + "lib/api/xmlrpc.php"
	devKey = conf['testlink']['devkey']
	vOutputdir = conf['testlink']['outputdirectory']
	testdir = conf['testlink']['testingdirectory']
    logdir = conf['general']['logdir']

	logger.debug('Getting parameters from command line')

	# catching the arguments Testlink sends 
    #s = sys.argv[1] + " " + sys.argv[2] + " " + sys.argv[3] + " " + sys.argv[4] + " " + sys.argv[5] + " " + sys.argv[6] + " " + sys.argv[7] + " " + sys.argv[8]
    logger.debug('Testvalues gained: %s', sys.argv)

    #argv1= testCaseName
	#argv2= testCaseID
	#argv3= testCaseVersionID
	#argv4= testProjectID
	#argv5= testPlanID
	#argv6= platformID
	#argv7= buildID
	#argv8= executionMode


	# TestLink API could be used for getting values, for example test case names or 
	# project names directly from Testlink database. Those could be used as folder names
	# when combined with GIT
	# Dev key is needed for database access
	
    logger.debug('start testlink API')
	# this starts up the Testlink API
	client = TestLinkAPI.TestlinkAPIClient(SERVER_URL, devKey)

	# polling some needed data from TL database using TestLink API
	projectinfo=(client.getProjects())
	logger.debug('Got Testlink projects info: %s', projectinfo)
	
	prefix = ""
	i = 0
	while prefix == "":
		if projectinfo[i]['id'] == sys.argv[4]:
			prefix = projectinfo[i]['prefix']
		else: 
			i = i + 1
	
	tcidlist=(client.getTestCaseIDByName(sys.argv[1]))
	logger.debug('Got test case IDs from poll: %s', tcidlist)

	tcinfo=(client.getTestCase(prefix + "-" + tcidlist[0]['tc_external_id']))
    logger.debug('Got test case information from poll: %s', tcinfo)

	tclist=(client.getTestCasesForTestPlan(sys.argv[5]))
	logger.debug('Got all test cases for Plan')

	cfEngine=(client.getTestCaseCustomFieldDesignValue(prefix + "-" + tcidlist[0]['tc_external_id'], tcinfo[0]['version'], sys.argv[4], "testingEngine", ""))
    logger.debug('Got engine from custom field: %s', cfEngine)

	cfScripts=(client.getTestCaseCustomFieldDesignValue(prefix + "-" + tcidlist[0]['tc_external_id'], tcinfo[0]['version'], sys.argv[4], "scriptNames", ""))
    logger.debug('Got runnable tests from custom field: %s', cfScripts)	
	
	runtimes=(client.getTestCaseCustomFieldDesignValue(prefix + "-" + tcidlist[0]['tc_external_id'], tcinfo[0]['version'], sys.argv[4], "runTimes", ""))
    logger.debug('Got runtimes from custom field: %s', runtimes)

	tolerance=(client.getTestCaseCustomFieldDesignValue(prefix + "-" + tcidlist[0]['tc_external_id'], tcinfo[0]['version'], sys.argv[4], "tolerance", ""))
    logger.debug('Got tolerance from custom field: %s', tolerance)

	
	noproblems = 1
	engine_defined = False
	cls = Engine
	engines = []
	
	# defining Git class
	puller = gitpuller()

	# finding all Engine subclasses

	path = "./"	# will look for classes under the folder where this script is installed and under its subclasses
    	for root, dirs, files in os.walk(path):
        	for name in files:
            		if name.endswith(".py") and name.startswith("engine_"):
                		path = os.path.join(root, name)
                		modulename = path.rsplit('.', 1)[0].replace('/', '.')
				modulename = modulename.rsplit('.', 1)[1]
                		result = look_for_subclass(modulename)
				if result == "error":
					break
	
	
	for e in engines:	#scroll through all found engines and find the correct one 
		if e.__name__ == cfEngine:
			engine = e(sys.argv[2], vOutputdir, testdir, sys.argv[8])
			engine_defined = True
			break

	if engine_defined == False:
		t = datetime.now()
		timestamp = t.strftime("%Y-%m-%d %H:%M:%S")
		logger.critical('The correct testing engine was not found, tests cannot be run. Check the custom field value')
		resultstring = "b@@The correct testing engine was not found, tests cannot be run. Check the custom field value.@@" + timestamp + "@@now"
	else:
		# pull the latest test script versions from Git
		# TODO: maybe add a custom field / configuration and code for pulling from svn?
        	gitresult = puller.pull(testdir)
        	if gitresult != "ok":
        	        logger.critical('Git error: "%s", running old tests...', gitresult)
        	        #noproblems = 0

	
		# how many times to run the tests, run at least one time 
		try:
			runtimes = int(runtimes)
		except Exception, e:
			# runtimes is not a number
			logger.critical('Custom field "RunTimes" contains an invalid value, tests will be run only once')
			runtimes = 1


		# getting testing scripts
		scriptlist = cfScripts.split()

		eninge.init_environment()

		if noproblems == 1:
			# if everything is ok, run the tests
			logger.debug('Starting Engine')
			
			engineresult = engine.run_tests(sys.argv[1], scriptlist, runtimes)
			if engineresult != "ok":
				t = datetime.now()
                		timestamp = t.strftime("%Y-%m-%d %H:%M:%S")
        	        	logger.critical('Engine error: %s', engineresult)
				resultstring = "b@@Engine error: " + engineresult + "@@" + timestamp + "@@now"
				noproblems = 0

		if noproblems == 1:
			# Trying to get the results from engine
			logger.debug('Trying to get test results')
			results = engine.get_test_results(sys.argv[1], runtimes, tolerance)
		

			resultstring = results[0] + "@@" + results[1] + "@@" + results[2] + "@@" + results[3]
	
		engine.teardown_environment()

	# Since the server saves the console output to a variable, I'll use print for 
	# returning the results
	# All results must be returned as one string

	# hardcoded return values for testing purposes
	#result = "p"
	#notes = "Just testing"
	#scheduled = sys.argv[8]
	#t = datetime.now()
    #timestamp = t.strftime("%Y-%m-%d %H:%M:%S")
	
	 
    logger.debug('Returning results: %s', resultstring)
	print resultstring
